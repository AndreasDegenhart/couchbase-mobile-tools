%{
#include "n1ql_parser_internal.hh"
%}

n1ql =
    _ s:selectStatement _ !.        {*sN1QLResult = s;}

selectStatement =
    SELECT _ ( d:DISTINCT _)? sr:selectResults
        (_ f:from )? (_ w:where )? (_ g:groupBy )? (_ o:orderBy )?
        (_ LIMIT _ l:expression ( _ OFFSET _ off:expression )?)?
        (_ ';')?
        {
            std::cerr << "select!\n";
            MutableDict select = MutableDict::newDict();
            if (!d.isNull())
                select.set("DISTINCT"_sl, true);
            select.set("WHAT"_sl, sr.as<MutableArray>());
            setAny(select, "WHERE"_sl, w);
            setAny(select, "GROUP BY"_sl, g);
            setAny(select, "ORDER BY"_sl, o);
            setAny(select, "LIMIT"_sl, l);
            setAny(select, "OFFSET"_sl, off);
            $$ = select;
        }

selectResults =
    sr:selectResult             { sr = arrayWith(sr); }
      (_ ',' _ sr2:selectResult { appendAny(sr.as<MutableArray>(), sr2);  }
      )*                        { $$ = sr; }

selectResult =
    ( ds:dataSourceName _ '.' _ )? '*' (_ AS __ ca:columnAlias )?
        { $$ = arrayWith("*"); /*FIX*/ }
    | x:expression (_ AS __ ca:columnAlias )?
        {
            assert(!x.isNull());
            if (ca.isNull()) {
                $$ = x;
            } else {
                $$ = op("AS", x, ca);
            }
        }

columnAlias     = IDENTIFIER        {std::cerr << "columnAlias\n";}
dataSourceName  = IDENTIFIER        {std::cerr << "dataSourceName\n";}
databaseName    = IDENTIFIER
databaseAlias   = IDENTIFIER

from =
    FROM __ ( dataSource | joins )

dataSource =
    databaseName ( _ AS __ databaseAlias )?

joins =
    dataSource ( joinOperator _ dataSource _ joinConstraint )*

joinOperator =
    ( LEFT (__ OUTER)? __ | INNER __ | CROSS __ )? JOIN

joinConstraint =
    ( ON _ expression )?

where =
    WHERE _ x:expression

groupBy =
    GROUP _ BY _ expression ( _ ',' _ expression )* ( _ having )?

having =
    HAVING _ expression

orderBy =
    ORDER _ BY _ o:ordering     { o = arrayWith(o); }
      ( _ ',' _ o2:ordering     { appendAny(o.as<MutableArray>(), o2); }
      )*                        { $$ = o; }

ordering =
    x:expression ( _ o:order )?
        { $$ = (o.isNull() ? x : Any(op(o.as<string>(), x))); }

order =
    ( ASC | DESC )


######## EXPRESSIONS:

expression = expr6
#
#  | expression '||' expression
#  | expression ('*' | '|' | '%') expression
#   | expression ('+'|'-') expression
#  | expression ('<'|'<='|'>'|'>=') expression
#  | expression ('='|'=='|'!='|'<>'|LIKE|REGEX|MATCH) expression
#  | expression IS (__ NOT?) expression
#  | expression (NOT __)? IN expression
#  | expression BETWEEN expression AND expression
#  | anyEvery variableName IN expression SATISFIES expression
#  | NOT expression
#  | expression AND expression
#  | expression OR expression
#  | function

expr6 =
    l:expr5 op:OP_PREC_6 r:expr6    {$$ = binaryOp(l, op, r);}
  | expr5

expr5 =
    l:expr4 op:OP_PREC_5 r:expr5    {$$ = binaryOp(l, op, r);}
  | expr4

expr4 =
    l:expr3 op:OP_PREC_4 r:expr4    {$$ = binaryOp(l, op, r);}
  | expr3

expr3 =
    l:expr2 op:OP_PREC_3 r:expr3    {$$ = binaryOp(l, op, r);}
  | expr2

expr2 =
    l:expr1 op:OP_PREC_2 r:expr2    {$$ = binaryOp(l, op, r);}
  | expr1

expr1 =
    l:expr0 op:OP_PREC_1 r:expr1    {$$ = binaryOp(l, op, r);}
  | expr0

expr0 =
    literal
  | property
  | meta
  | function
  | '(' expression ')'
  | op:OP_PREFIX r:expr0            {$$ = unaryOp(op, r);}

OP_PREC_8 = <OR>                {$$ = string(yytext);}
OP_PREC_7 = <AND>               {$$ = string(yytext);}
OP_PREC_6 = <'=='|'='|'!='|'<>'| IS (__ NOT)? | (NOT __)? IN | LIKE |MATCH >
                                {$$ = string(yytext);}
OP_PREC_5 = <'<='|'<'|'>='|'>'> {$$ = string(yytext);}
OP_PREC_4 = <'<<'|'>>'|'&'|'|'> {$$ = string(yytext);}
OP_PREC_3 = <[-+]>              {$$ = string(yytext);}
OP_PREC_2 = <[*/%]>             {$$ = string(yytext);}
OP_PREC_1 = <'||'>              {$$ = string(yytext);}
OP_PREFIX = <'-'|'+'|'~'|NOT>   {$$ = string(yytext);}


meta =
    ( dataSourceName _ '.' _ )? META _ '.' _ propertyName

property =
    p:propertyName ( _ '.' _ p2:propertyName
        {p = p.as<string>() + "." + p2.as<string>();}
    )*
        {
            auto property = p.as<string>();
            std::cerr << "property: " << property << "\n";
            $$ = arrayWith(slice(string(".") + property));
        }

function =
    functionName '(' ( expression ( ',' expression )* )? ')'

anyEvery =
    ( ANY | EVERY | ANY __ AND __ EVERY )

functionName    = IDENTIFIER
propertyName    = IDENTIFIER
variableName    = IDENTIFIER


IDENTIFIER =
    <[a-zA-Z_] [a-zA-Z_0-9]*>           {$$ = string(yytext); std::cerr << "ID: " << yytext << "\n";}
  | '"' <( !'"' | '""' )*> '"'          {$$ = unquote(yytext, '"'); std::cerr << "ID: quoted " << yytext << "\n";}


######## KEYWORDS:

AND      = "AND"
ANY      = "ANY"
AS       = "AS"
ASC      = "ASC"
BETWEEN  = "BETWEEN"
BY       = "BY"
CROSS    = "CROSS"
DESC     = "DESC"
DISTINCT = "DISTINCT"   {$$ = true;}
EVERY    = "EVERY"
FROM     = "FROM"
GROUP    = "GROUP"
HAVING   = "HAVING"
IN       = "IN"
INNER    = "INNER"
IS       = "IS"
JOIN     = "JOIN"
LEFT     = "LEFT"
LIKE     = "LIKE"
LIMIT    = "LIMIT"
MATCH    = "MATCH"
META     = "META"
NOT      = "NOT"
OFFSET   = "OFFSET"
ON       = "ON"
OR       = "OR"
ORDER    = "ORDER"
OUTER    = "OUTER"
REGEX    = "REGEX"
SATISFIES = "SATISFIES"
SELECT   = "SELECT"
WHERE    = "WHERE"


######## LITERALS:

literal =
    NUMERIC_LITERAL     {std::cerr << "numeric_literal\n";}
  | BOOLEAN_LITERAL
  | STRING_LITERAL
  | "NULL"              {$$ = string("null"); /*FIX*/}
  | "MISSING"           {$$ = arrayWith("MISSING");}

BOOLEAN_LITERAL =
    "TRUE"              {$$ = true;}
  | "FALSE"             {$$ = false;}

NUMERIC_LITERAL =
    (<'-'? DIGIT+ ( '.' DIGIT* )? ( [Ee] [-+]? DIGIT+ )?>
  |  <'-'? '.' DIGIT+ ( [Ee] [-+]? DIGIT+ )?>)
        {
            std::cerr << "numeric: " << atoi(yytext) << "\n";
            $$ = (long long)atoi(yytext); //FIX
        }

STRING_LITERAL =
    "'" <( [^'] | "''" )*> "'"
        {
            std::cerr << "string literal: " << yytext << "\n";
            $$ = unquote(yytext, '\'');
        }

DIGIT =
    [0-9]

_  =
    [ \t\r\n]*            # Optional whitespace
__  =
    [ \t\r\n]+            # Mandatory whitespace

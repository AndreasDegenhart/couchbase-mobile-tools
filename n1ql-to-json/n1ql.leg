# Grammar file for N1QL parser
# To be compiled by the 'leg' tool with Jens's modifications -- <http://github.com/snej/peg/>:
#     leg -o n1ql.cc n1ql.leg
# The output file must be compiled as C++!

%{
#include "n1ql_parser_internal.hh"
%}

n1ql =
    _ s:selectStatement _ !.            { $$ = s;}


######## SELECT STATEMENT:


selectStatement =
    SELECT _ 
        (d:DISTINCT)?
        sr:selectResults _
        (f:from _ )?
        (WHERE w:expression)? 
        (g:groupBy _ h:having?)? 
        (o:orderBy _)?
        (LIMIT l:expression ( _ OFFSET off:expression )?)?
        (_ ';')?
                                        { MutableDict select = MutableDict::newDict();
                                          setAny(select, "DISTINCT"_sl, d);
                                          setAny(select, "WHAT"_sl, sr);
                                          setAny(select, "FROM"_sl, f);
                                          setAny(select, "WHERE"_sl, w);
                                          setAny(select, "GROUP_BY"_sl, g);
                                          setAny(select, "HAVING"_sl, h);
                                          setAny(select, "ORDER_BY"_sl, o);
                                          setAny(select, "LIMIT"_sl, l);
                                          setAny(select, "OFFSET"_sl, off);
                                          $$ = select; }

selectResults =
    sr:selectResult                     { sr = arrayWith(sr); }
      (_ ',' _ sr2:selectResult         { appendAny(sr, sr2);  }
      )*                                { $$ = sr; }

selectResult =
    x:expression (_ AS ca:columnAlias )?
                                        { assert(!x.isNull());
                                          if (ca.isNull())
                                            $$ = x;
                                          else
                                            $$ = op("AS", x, ca); }

from =
    FROM d:dataSource                   { d = arrayWith(d);}
        (j:join                         { appendAny(d, j);}
         )*                             { $$ = d;}

dataSource =
    n:databaseName (AS a:databaseAlias )?  { $$ = dictWith("AS"_sl, a.isNull() ? n : a);}

join =
    o:joinOperator _ s:dataSource _ c:joinConstraint
                                        { MutableDict j = s;
                                          setAny(j, "JOIN"_sl, o);
                                          setAny(j, "ON"_sl, c);
                                          $$ = j; }

joinOperator =
    <( LEFT (OUTER)? | INNER | CROSS )?> JOIN
                                        { $$ = (*yytext ? trim(yytext) : string("LEFT"));}

joinConstraint =
    ( ON expression )?

groupBy =
    GROUP BY x:expression               { x = arrayWith(x);}
        ( _ ',' _ x2:expression         { appendAny(x, x2);}
        )*                              { $$ = x;}

having =
    HAVING expression

orderBy =
    ORDER BY o:ordering                 { o = arrayWith(o); }
        ( _ ',' _ o2:ordering           { appendAny(o, o2); }
        )*                              { $$ = o; }

ordering =
    x:expression
        ( _ o:order                     { x = op(o, x);}
        )?                              { $$ = x; }

order =
    <( ASC | DESC )>                    { $$ = trim(yytext);}

columnAlias     = IDENTIFIER
dataSourceName  = IDENTIFIER
databaseName    = IDENTIFIER
databaseAlias   = IDENTIFIER


######## EXPRESSIONS:

expression =
    caseExpression
  | anyEveryExpression
  | expr8


caseExpression =
    CASE (!WHEN val:expression)?        { val = op("CASE", (val.isNull() ? Any(nullValue) : val));}
    (WHEN when:expression THEN then:expression
                                        {
                                          appendAny(val, when);
                                          appendAny(val, then);
                                        }
        )+
    (ELSE elsex:expression              { appendAny(val, elsex);}
        )? END                          {  $$ = val; }


anyEveryExpression =
    a:anyEvery _ v:variableName _ IN _ e:expression _ SATISFIES _ s:expression
                                        {
                                          if (s.is<MutableArray>())
                                            substituteVariable(v, s);
                                          auto oper = arrayWith(a);
                                          appendAny(oper, v);
                                          appendAny(oper, e);
                                          appendAny(oper, s);
                                          $$ = oper;
                                        }

anyEvery =
    ANY                                 { $$ = string("ANY");}
  | EVERY                               { $$ = string("EVERY");}
  | ANY AND EVERY                       { $$ = string("ANY AND EVERY");}

variableName    = IDENTIFIER


# Every level of operator precedence needs its own grammar rule, to ensure that operations
# are grouped correctly. The precedence levels here are taken from the SQLite documentation.
# Level 8 is the lowest, level 0 the highest.

expr8 =
    x:expr7 (_ op:OP_PREC_8 _ r:expr7   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr7 =
    x:expr6 (_ op:OP_PREC_7 _ r:expr6   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr6 =
    x:expr5 NOT NULL                    { $$ = op("IS NOT", x, nullValue); }
  | x:expr5 BETWEEN min:expr5 AND max:expr5  { $$ = op("BETWEEN", x, min, max);}
  | x:expr5 (_ o:OP_PREC_6 _ r:expr5    { x = binaryOp(x, o, r);}
             )*                         { $$ = x}
expr5 =
    x:expr4 (_ op:OP_PREC_5 _ r:expr4   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr4 =
    x:expr3 (_ op:OP_PREC_4 _ r:expr3   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr3 =
    x:expr2 (_ op:OP_PREC_3 _ r:expr2   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr2 =
    x:expr1 (_ op:OP_PREC_2 _ r:expr1   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr1 =
    x:expr0 (_ op:OP_PREC_1 _ r:expr0   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}


# Binary operators, by precedence:

OP_PREC_8 = OR                          { $$ = string("OR");}
OP_PREC_7 = AND                         { $$ = string("AND");}
OP_PREC_6 = ('=='|'=')                  { $$ = string("=");}
          | ('<>'|'!=')                 { $$ = string("!=");}
          | (NOT IN)                    { $$ = string("NOT IN");}
          | (IS NOT)                    { $$ = string("IS NOT");}
          | <(IN|IS|LIKE|MATCH)>        { $$ = trim(yytext);}
OP_PREC_5 = <('<='|'<'|'>='|'>')>       { $$ = trim(yytext);}
OP_PREC_4 = <('<<'|'>>'|'&'|'|')>       { $$ = trim(yytext);}
OP_PREC_3 = <[-+]>                      { $$ = trim(yytext);}
OP_PREC_2 = <[*/%]>                     { $$ = trim(yytext);}
OP_PREC_1 = <'||'>                      { $$ = trim(yytext);}

# Collation:

expr0 =
    x:baseExpr
    (_ COLLATE c:collation              { x = collateOp(x, c); }
        ( _ c2:collation                { extendCollate(x, c2); }
         )*
     )?                                 { $$ = x; }

collation =
    <("NO"i? ("UNICODE"i | "CASE"i | "DIACRITICS"i)> WB)  { $$ = string(yytext); }

# Indivisible expressions:

baseExpr =
    literal
  | op:OP_PREFIX _ r:baseExpr           { $$ = unaryOp(op, r);}
  | parameter
  | function
  | meta
  | property
  | '(' _ expression _ ')'

OP_PREFIX = <('-'|'+'|'~'|NOT)>         { $$ = trim(yytext);}


parameter =
    '$' IDENTIFIER                      {$$ = arrayWith(string("$") + yytext);}


meta =
    ds:dataSourceName _ '.' _ META '.' _ <metaProperty>
                                        { $$ = arrayWith(string(".") + ds.as<string>()
                                                + "._" + yytext);}
  | META '.' _ <metaProperty>           { $$ = arrayWith(string("._") + yytext);}

metaProperty =
    "id" | "sequence" | "deleted" | "expiration"


property =
    '*'                                 { $$ = arrayWith(".");}
  | a:databaseAlias '.' _ '*'           { $$ = arrayWith("." + a.as<string>() + ".");}
  | p:propertyName                      { p = quoteProperty(p); }
        ('.' _ p2:propertyName          { p = p.as<string>() + quoteProperty(p2);}
         )*                             { $$ = arrayWith(slice(p.as<string>()));}

propertyName    = !META IDENTIFIER


function =
    f:functionName _ '('                { f = arrayWith(f.as<string>() + "()");}
        ( e:expression                  { appendAny(f, e);}
        (_ ',' _ e2:expression          { appendAny(f, e2);}
        )* )? ')'                       { $$ = f;}

functionName    = IDENTIFIER


######## IDENTIFIERS & KEYWORDS:


IDENTIFIER =
  <[a-zA-Z_] [a-zA-Z_0-9]*>            &{!isReservedWord(yytext)}
        _                               { $$ = string(yytext);}
  | "\"" <( [^"] | "\"\"" )*> "\"" _    { $$ = unquote(yytext, '"');}


# Note: the 'i' suffix on strings makes them case-insensitive.
# This feature is not in the stock peg-1.1.8 distribution, but is in the one on Github.

AND       = "AND"i         WB
ANY       = "ANY"i         WB
AS        = "AS"i          WB
ASC       = "ASC"i         WB
BETWEEN   = "BETWEEN"i     WB
BY        = "BY"i          WB
CASE      = "CASE"i        WB
COLLATE   = "COLLATE"i     WB
CROSS     = "CROSS"i       WB
DESC      = "DESC"i        WB
DISTINCT  = "DISTINCT"i    WB           { $$ = true}
ELSE      = "ELSE"i        WB
END       = "END"i         WB
EVERY     = "EVERY"i       WB
FALSE     = "FALSE"i       WB
FROM      = "FROM"i        WB
GROUP     = "GROUP"i       WB
HAVING    = "HAVING"i      WB
IN        = "IN"i          WB
INNER     = "INNER"i       WB
IS        = "IS"i          WB
JOIN      = "JOIN"i        WB
LEFT      = "LEFT"i        WB
LIKE      = "LIKE"i        WB
LIMIT     = "LIMIT"i       WB
MATCH     = "MATCH"i       WB
META      = "META"i        WB
MISSING   = "MISSING"i     WB
NATURAL   = "NATURAL"i     WB
NOT       = "NOT"i         WB
NULL      = "NULL"i        WB
MISSING   = "MISSING"i     WB
OFFSET    = "OFFSET"i      WB
ON        = "ON"i          WB
OR        = "OR"i          WB
ORDER     = "ORDER"i       WB
OUTER     = "OUTER"i       WB
REGEX     = "REGEX"i       WB
RIGHT     = "RIGHT"i       WB
SATISFIES = "SATISFIES"i   WB
SELECT    = "SELECT"i      WB
THEN      = "THEN"i        WB
TRUE      = "TRUE"i        WB
USING     = "USING"i       WB
WHEN      = "WHEN"i        WB
WHERE     = "WHERE"i       WB


######## LITERALS:


literal =
    NUMERIC_LITERAL
  | BOOLEAN_LITERAL
  | STRING_LITERAL
  | NULL                                { $$ = nullValue; }
  | MISSING                             { $$ = arrayWith("MISSING");}

BOOLEAN_LITERAL =
    TRUE                                { $$ = true;}
  | FALSE                               { $$ = false;}

NUMERIC_LITERAL =
    <'-'? (('.' DIGIT+) | (DIGIT+ ('.' DIGIT*)?)) ( [Ee] [-+]? DIGIT+ )?> WB
                                        {
                                          double d;
                                          sscanf(yytext, "%lf", &d);
                                          $$ = d;
                                        }
  | <'-'? DIGIT+> WB                    { $$ = (long long)atoi(yytext);}

DIGIT = [0-9]


STRING_LITERAL =
    "'" <( [^'] | "''" )*> "'" _        { $$ = unquote(yytext, '\'');}


WB = ![a-zA-Z0-9_] _       # Word break + optional whitespace
_  = [ \t\r\n]*            # Optional whitespace


%%
//////// PARSER ENTRY POINT (C++):


#undef __


static int n1ql_input(yycontext *ctx, char *buf, size_t max_size) {
    ctx->stream->get(buf, max_size+1, -1);
    return (int) ctx->stream->gcount();
}


MutableDict n1ql_parse(const string &input, int *errPos) {
    MutableDict result;
    std::stringstream stream(input);
    yycontext ctx = { };
    ctx.stream = &stream;

    bool ok = n1ql_parse(&ctx) != 0;
    if (ok) {
        result = ctx.__;
    } else {
        *errPos = ctx.__maxpos;
    }
    yyrelease(&ctx);
    return result;
}

# Grammar file for N1QL parser
# To be compiled by the 'leg' tool with Jens's modifications -- <http://github.com/snej/peg/>

%{
#include "n1ql_parser_internal.hh"
%}

n1ql =
    _ s:selectStatement _ !.            { *sN1QLResult = s;}


######## SELECT STATEMENT:


selectStatement =
    SELECT _ 
        ( d:DISTINCT)? 
        sr:selectResults _
        (f:from _ )?
        (WHERE w:expression)? 
        (g:groupBy _ h:having?)? 
        (o:orderBy _)?
        (LIMIT l:expression ( _ OFFSET off:expression )?)?
        (_ ';')?
                                        { MutableDict select = MutableDict::newDict();
                                          if (!d.isNull())
                                             select.set("DISTINCT"_sl, true);
                                          setAny(select, "WHAT"_sl, sr);
                                          setAny(select, "FROM"_sl, f);
                                          setAny(select, "WHERE"_sl, w);
                                          setAny(select, "GROUP BY"_sl, g);
                                          setAny(select, "HAVING"_sl, h);
                                          setAny(select, "ORDER BY"_sl, o);
                                          setAny(select, "LIMIT"_sl, l);
                                          setAny(select, "OFFSET"_sl, off);
                                          $$ = select; }

selectResults =
    sr:selectResult                     { sr = arrayWith(sr); }
      (_ ',' _ sr2:selectResult         { appendAny(sr, sr2);  }
      )*                                { $$ = sr; }

selectResult =
    ( ds:dataSourceName _ '.' _ )? '*' (_ AS ca:columnAlias )?
                                        { string src = ".";
                                         if (!ds.isNull())
                                            src += ds.as<string>() + ".";
                                         $$ = arrayWith(src); }
    | x:expression (_ AS ca:columnAlias )?
                                        { assert(!x.isNull());
                                          if (ca.isNull())
                                            $$ = x;
                                          else
                                            $$ = op("AS", x, ca); }

from =
    FROM d:dataSource                   { d = arrayWith(d);}
        (j:join                         { appendAny(d, j);}
         )*                             { $$ = d;}

dataSource =
    n:databaseName (AS a:databaseAlias )?  { $$ = dictWith("AS"_sl, a.isNull() ? n : a);}

join =
    o:joinOperator _ s:dataSource _ c:joinConstraint
                                        { MutableDict j = s;
                                          j.set("JOIN"_sl, o.as<string>().c_str());
                                          setAny(j, "ON"_sl, c);
                                          $$ = j; }

joinOperator =
    <( LEFT (OUTER)? | INNER | CROSS )?> JOIN
                                        { $$ = (*yytext ? trim(yytext) : string("LEFT"));}

joinConstraint =
    ( ON expression )?

groupBy =
    GROUP BY x:expression               { x = arrayWith(x);}
        ( _ ',' _ x2:expression         { appendAny(x, x2);}
        )*                              { $$ = x;}

having =
    HAVING expression

orderBy =
    ORDER BY o:ordering                 { o = arrayWith(o); }
        ( _ ',' _ o2:ordering           { appendAny(o, o2); }
        )*                              { $$ = o; }

ordering =
    x:expression
        ( _ o:order                     { x = op(o, x);}
        )?                              { $$ = x; }

order =
    <( ASC | DESC )>                    { $$ = trim(yytext);}

columnAlias     = IDENTIFIER
dataSourceName  = IDENTIFIER
databaseName    = IDENTIFIER
databaseAlias   = IDENTIFIER


######## EXPRESSIONS:


expression =
    a:anyEvery v:variableName IN e:expression SATISFIES s:expression
      {
        auto oper = arrayWith(a);
        oper.append(v.as<string>().c_str());
        appendAny(oper, e);
        appendAny(oper, s);
        $$ = oper;
      }
  | e:expr6 BETWEEN min:expression AND max:expression
                                        { $$ = op("BETWEEN", min, max);}
  | expr8

expr8 =
    x:expr7 (_ op:OP_PREC_8 _ r:expr7   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr7 =
    x:expr6 (_ op:OP_PREC_7 _ r:expr6   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr6 =
    x:expr5 (_ op:OP_PREC_6 _ r:expr5   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr5 =
    x:expr4 (_ op:OP_PREC_5 _ r:expr4   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr4 =
    x:expr3 (_ op:OP_PREC_4 _ r:expr3   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr3 =
    x:expr2 (_ op:OP_PREC_3 _ r:expr2   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr2 =
    x:expr1 (_ op:OP_PREC_2 _ r:expr1   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr1 =
    x:expr0 (_ op:OP_PREC_1 _ r:expr0   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}

expr0 =
    literal
  | function
  | property
  | meta
  | '(' _ expression _ ')'
  | op:OP_PREFIX _ r:expr0              { $$ = unaryOp(op, r);}

OP_PREC_8 = <OR>                        { $$ = trim(yytext);}
OP_PREC_7 = <AND>                       { $$ = trim(yytext);}
OP_PREC_6 = <('=='|'='|'!='|'<>'
              |IN|IS|LIKE|MATCH)>       { $$ = trim(yytext);}
          | NOT_IN | IS_NOT
OP_PREC_5 = <('<='|'<'|'>='|'>')>       { $$ = trim(yytext);}
OP_PREC_4 = <('<<'|'>>'|'&'|'|')>       { $$ = trim(yytext);}
OP_PREC_3 = <[-+]>                      { $$ = trim(yytext);}
OP_PREC_2 = <[*/%]>                     { $$ = trim(yytext);}
OP_PREC_1 = <'||'>                      { $$ = trim(yytext);}
OP_PREFIX = <('-'|'+'|'~'|NOT)>         { $$ = trim(yytext);}


meta =
    ( dataSourceName _ '.' _ )? META '.' _ propertyName

property =
    p:propertyName
        ( _ '.' _ p2:propertyName       { p = p.as<string>() + "." + p2.as<string>();}
         )*                             { $$ = arrayWith(slice(string(".") + p.as<string>()));}

function =
    f:functionName _ '('                { f = arrayWith(f.as<string>() + "()");}
        ( e:expression                  { appendAny(f, e);}
        (_ ',' _ e2:expression          { appendAny(f, e2);}
        )* )? ')'                       { $$ = f;}

anyEvery =
    ANY                                 { $$ = string("ANY");}
  | EVERY                               { $$ = string("EVERY");}
  | ANY AND EVERY                       { $$ = string("ANY AND EVERY");}

functionName    = IDENTIFIER
propertyName    = IDENTIFIER
variableName    = IDENTIFIER



######## IDENTIFIERS & KEYWORDS:


IDENTIFIER =
    <[a-zA-Z_] [a-zA-Z_0-9]*> _         { $$ = string(yytext);}
  | "\"" <( [^"] | "\"\"" )*> "\"" _    { $$ = unquote(yytext, '"');}


# Note: the 'i' suffix on strings makes them case-insensitive.
# This feature is not in the stock peg-1.1.8 distribution, but is in the one on Github.

AND       = "AND"i         WB
ANY       = "ANY"i         WB
AS        = "AS"i          WB
ASC       = "ASC"i         WB
BETWEEN   = "BETWEEN"i     WB
BY        = "BY"i          WB
CROSS     = "CROSS"i       WB
DESC      = "DESC"i        WB
DISTINCT  = "DISTINCT"i    WB           { $$ = true}
EVERY     = "EVERY"i       WB
FALSE     = "FALSE"i       WB
FROM      = "FROM"i        WB
GROUP     = "GROUP"i       WB
HAVING    = "HAVING"i      WB
IN        = "IN"i          WB
INNER     = "INNER"i       WB
IS        = "IS"i          WB
JOIN      = "JOIN"i        WB
LEFT      = "LEFT"i        WB
LIKE      = "LIKE"i        WB
LIMIT     = "LIMIT"i       WB
MATCH     = "MATCH"i       WB
META      = "META"i        WB
MISSING   = "MISSING"i     WB
NATURAL   = "NATURAL"i     WB
NOT       = "NOT"i         WB
NULL      = "NULL"i        WB
MISSING   = "MISSING"i     WB
OFFSET    = "OFFSET"i      WB
ON        = "ON"i          WB
OR        = "OR"i          WB
ORDER     = "ORDER"i       WB
OUTER     = "OUTER"i       WB
REGEX     = "REGEX"i       WB
RIGHT     = "RIGHT"i       WB
SATISFIES = "SATISFIES"i   WB
SELECT    = "SELECT"i      WB
TRUE      = "TRUE"i        WB
USING     = "USING"i       WB
WHERE     = "WHERE"i       WB

IS_NOT    = IS NOT                      { $$ = string("IS NOT");}
NOT_IN    = NOT IN                      { $$ = string("NOT IN");}


######## LITERALS:


literal =
    NUMERIC_LITERAL
  | BOOLEAN_LITERAL
  | STRING_LITERAL
  | NULL _                              { $$ = string("null"); /*FIX*/}
  | MISSING _                           { $$ = arrayWith("MISSING");}

BOOLEAN_LITERAL =
    TRUE _                              { $$ = true;}
  | FALSE _                             { $$ = false;}

NUMERIC_LITERAL =
    <'-'? (('.' DIGIT+) | (DIGIT+ ('.' DIGIT*)?)) ( [Ee] [-+]? DIGIT+ )?>
        {
            double d;
            sscanf(yytext, "%lf", &d);
            $$ = d;
        }
  | <'-'? DIGIT+>                       { $$ = (long long)atoi(yytext);}

STRING_LITERAL =
    "'" <( [^'] | "''" )*> "'" _        { $$ = unquote(yytext, '\'');}

DIGIT = [0-9]

WB = ![a-zA-Z0-9_] _       # Word break
_  = [ \t\r\n]*            # Optional whitespace

%%


int n1ql_parse() {
    yycontext ctx = { };
    auto result = n1ql_parse(&ctx);
    yyrelease(&ctx);
    return result;
}

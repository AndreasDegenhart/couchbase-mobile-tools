%{
#include "n1ql_parser_internal.hh"
%}

n1ql =
    _ s:selectStatement _ !.        {*sN1QLResult = s;}

selectStatement =
    SELECT _ ( d:DISTINCT _)? sr:selectResults
        (_ f:from )? (_ w:where )? (_ g:groupBy )? (_ o:orderBy )?
        (_ LIMIT _ l:expression ( _ OFFSET _ off:expression )?)?
        (_ ';')?
        {
            std::cerr << "select!\n";
            MutableDict select = MutableDict::newDict();
            if (!d.isNull())
                select.set("DISTINCT"_sl, true);
            select.set("WHAT"_sl, sr.as<MutableArray>());
            setAny(select, "WHERE"_sl, w);
            setAny(select, "GROUP BY"_sl, g);
            setAny(select, "ORDER BY"_sl, o);
            setAny(select, "LIMIT"_sl, l);
            setAny(select, "OFFSET"_sl, off);
            $$ = select;
        }

selectResults =
    sr:selectResult             { sr = arrayWith(sr); }
      (_ ',' _ sr2:selectResult { appendAny(sr.as<MutableArray>(), sr2);  }
      )*                        { $$ = sr; }

selectResult =
    ( ds:dataSourceName _ '.' _ )? '*' (_ AS __ ca:columnAlias )?
        { $$ = arrayWith("*"); /*FIX*/ }
    | x:expression (_ AS __ ca:columnAlias )?
        {
            assert(!x.isNull());
            if (ca.isNull()) {
                $$ = x;
            } else {
                $$ = op("AS", x, ca);
            }
        }

columnAlias     = IDENTIFIER        {std::cerr << "columnAlias\n";}
dataSourceName  = IDENTIFIER        {std::cerr << "dataSourceName\n";}
databaseName    = IDENTIFIER
databaseAlias   = IDENTIFIER

from =
    FROM __ ( dataSource | joins )

dataSource =
    databaseName ( _ AS __ databaseAlias )?

joins =
    dataSource ( joinOperator _ dataSource _ joinConstraint )*

joinOperator =
    ( LEFT (__ OUTER)? __ | INNER __ | CROSS __ )? JOIN

joinConstraint =
    ( ON _ expression )?

where =
    WHERE _ x:expression

groupBy =
    GROUP _ BY _ expression ( _ ',' _ expression )* ( _ having )?

having =
    HAVING _ expression

orderBy =
    ORDER _ BY _ o:ordering     { o = arrayWith(o); }
      ( _ ',' _ o2:ordering     { appendAny(o.as<MutableArray>(), o2); }
      )*                        { $$ = o; }

ordering =
    x:expression ( _ o:order )?
        { $$ = (o.isNull() ? x : Any(op(o.as<string>(), x))); }

order =
    ( ASC | DESC )


######## EXPRESSIONS:

expression =
    a:anyEvery v:variableName IN e:expression SATISFIES s:expression
      {
        auto oper = arrayWith(a);
        oper.append(v.as<string>().c_str());
        appendAny(oper, e);
        appendAny(oper, s);
        $$ = oper;
      }
  | e:expr6 BETWEEN min:expression AND max:expression
      {
        $$ = op("BETWEEN", min, max);
      }
  | expr6

expr6 =
    l:expr5 _ op:OP_PREC_6 _ r:expr6    {$$ = binaryOp(l, op, r);}
  | expr5

expr5 =
    l:expr4 _ op:OP_PREC_5 _ r:expr5    {$$ = binaryOp(l, op, r);}
  | expr4

expr4 =
    l:expr3 _ op:OP_PREC_4 _ r:expr4    {$$ = binaryOp(l, op, r);}
  | expr3

expr3 =
    l:expr2 _ op:OP_PREC_3 _ r:expr3    {$$ = binaryOp(l, op, r);}
  | expr2

expr2 =
    l:expr1 _ op:OP_PREC_2 _ r:expr2    {$$ = binaryOp(l, op, r);}
  | expr1

expr1 =
    l:expr0 _ op:OP_PREC_1 _ r:expr1    {$$ = binaryOp(l, op, r);}
  | expr0

expr0 =
    literal
  | property
  | meta
  | function
  | '(' _ expression _ ')'
  | op:OP_PREFIX _ r:expr0            {$$ = unaryOp(op, r);}

OP_PREC_8 = <OR>                  {$$ = string(yytext);}
OP_PREC_7 = <AND>                 {$$ = string(yytext);}
OP_PREC_6 = <('=='|'='|'!='|'<>'|IN|IS|LIKE|MATCH)>
                                  {$$ = string(yytext);}
        | NOT_IN | IS_NOT
OP_PREC_5 = <('<='|'<'|'>='|'>')>   {$$ = string(yytext);}
OP_PREC_4 = <('<<'|'>>'|'&'|'|')>   {$$ = string(yytext);}
OP_PREC_3 = <[-+]>                {$$ = string(yytext);}
OP_PREC_2 = <[*/%]>               {$$ = string(yytext);}
OP_PREC_1 = <'||'>                {$$ = string(yytext);}
OP_PREFIX = <('-'|'+'|'~'|NOT)>     {$$ = string(yytext);}


meta =
    ( dataSourceName _ '.' _ )? META _ '.' _ propertyName

property =
    p:propertyName ( _ '.' _ p2:propertyName
        {p = p.as<string>() + "." + p2.as<string>();}
    )*
        {
            auto property = p.as<string>();
            std::cerr << "property: " << property << "\n";
            $$ = arrayWith(slice(string(".") + property));
        }

function =
    functionName '(' ( expression ( ',' expression )* )? ')'

anyEvery =
    ANY                 {$$ = string("ANY");}
  | EVERY               {$$ = string("EVERY");}
  | ANY __ AND __ EVERY {$$ = string("ANY AND EVERY");}

functionName    = IDENTIFIER
propertyName    = IDENTIFIER
variableName    = IDENTIFIER


IDENTIFIER =
    <[a-zA-Z_] [a-zA-Z_0-9]*>           {$$ = string(yytext); std::cerr << "ID: " << yytext << "\n";}
  | '"' <( !'"' | '""' )*> '"'          {$$ = unquote(yytext, '"'); std::cerr << "ID: quoted " << yytext << "\n";}


######## KEYWORDS:

AND       = A N D
ANY       = A N Y
AS        = A S
ASC       = A S C
BETWEEN   = B E T W E E N
BY        = B Y
CROSS     = C R O S S
DESC      = D E S C
DISTINCT  = D I S T I N C T   {$$ = true}
EVERY     = E V E R Y
FALSE     = F A L S E
FROM      = F R O M
GROUP     = G R O U P
HAVING    = H A V I N G
IN        = I N
INNER     = I N N E R
IS        = I S
IS_NOT    = IS __ NOT    {$$ = string("IS NOT");}
JOIN      = J O I N
LEFT      = L E F T
LIKE      = L I K E
LIMIT     = L I M I T
MATCH     = M A T C H
META      = M E T A
MISSING   = M I S S I N G
NATURAL   = N A T U R A L
NOT       = N O T
NOT_IN    = NOT __ IN    {$$ = string("NOT IN");}
NULL      = N U L L
MISSING   = M I S S I N G
OFFSET    = O F F S E T
ON        = O N
OR        = O R
ORDER     = O R D E R
OUTER     = O U T E R
REGEX     = R E G E X
RIGHT     = R I G H T
SATISFIES = S A T I S F I E S
SELECT    = S E L E C T
TRUE      = T R U E
USING     = U S I N G
WHERE     = W H E R E


######## LITERALS:

literal =
    NUMERIC_LITERAL
  | BOOLEAN_LITERAL
  | STRING_LITERAL
  | NULL _            {$$ = string("null"); /*FIX*/}
  | MISSING _         {$$ = arrayWith("MISSING");}

BOOLEAN_LITERAL =
    TRUE _            {$$ = true;}
  | FALSE _           {$$ = false;}

NUMERIC_LITERAL =
    (<'-'? DIGIT+ ( '.' DIGIT* )? ( [Ee] [-+]? DIGIT+ )?>
  |  <'-'? '.' DIGIT+ ( [Ee] [-+]? DIGIT+ )?>) _
        {
            std::cerr << "numeric: " << atoi(yytext) << "\n";
            $$ = (long long)atoi(yytext); //FIX
        }

STRING_LITERAL =
    "'" <( [^'] | "''" )*> "'" _
        {
            std::cerr << "string literal: " << yytext << "\n";
            $$ = unquote(yytext, '\'');
        }

DIGIT = [0-9]

A = [aA]
B = [bB]
C = [cC]
D = [dD]
E = [eE]
F = [fF]
G = [gG]
H = [hH]
I = [iI]
J = [jJ]
K = [kK]
L = [lL]
M = [mM]
N = [nN]
O = [oO]
P = [pP]
Q = [qQ]
R = [rR]
S = [sS]
T = [tT]
U = [uU]
V = [vV]
W = [wW]
X = [xX]
Y = [yY]
Z = [zZ]

_  = [ \t\r\n]*            # Optional whitespace
__ = [ \t\r\n]+            # Mandatory whitespace

%%


int n1ql_parse() {
    yycontext ctx = {};
    auto result = n1ql_parse(&ctx);
    yyrelease(&ctx);
    return result;
}
